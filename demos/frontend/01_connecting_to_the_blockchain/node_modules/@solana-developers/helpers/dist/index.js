"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  addKeypairToEnvFile: () => addKeypairToEnvFile,
  airdropIfRequired: () => airdropIfRequired,
  confirmTransaction: () => confirmTransaction,
  getCustomErrorMessage: () => getCustomErrorMessage,
  getExplorerLink: () => getExplorerLink,
  getKeypairFromEnvironment: () => getKeypairFromEnvironment,
  getKeypairFromFile: () => getKeypairFromFile,
  getLogs: () => getLogs,
  getSimulationComputeUnits: () => getSimulationComputeUnits,
  initializeKeypair: () => initializeKeypair,
  keypairToSecretKeyJSON: () => keypairToSecretKeyJSON,
  makeKeypairs: () => makeKeypairs
});
module.exports = __toCommonJS(src_exports);
var import_web3 = require("@solana/web3.js");
var import_bs58 = __toESM(require("bs58"));
var import_path = __toESM(require("path"));
var import_promises = require("fs/promises");
var DEFAULT_FILEPATH = "~/.config/solana/id.json";
var DEFAULT_AIRDROP_AMOUNT = 1 * import_web3.LAMPORTS_PER_SOL;
var DEFAULT_MINIMUM_BALANCE = 0.5 * import_web3.LAMPORTS_PER_SOL;
var DEFAULT_ENV_KEYPAIR_VARIABLE_NAME = "PRIVATE_KEY";
var getErrorFromRPCResponse = (rpcResponse) => {
  const error = rpcResponse.value.err;
  if (error) {
    if (typeof error === "object") {
      const errorKeys = Object.keys(error);
      if (errorKeys.length === 1) {
        if (errorKeys[0] !== "InstructionError") {
          throw new Error(`Unknown RPC error: ${error}`);
        }
        const instructionError = error["InstructionError"];
        throw new Error(
          `Error in transaction: instruction index ${instructionError[0]}, custom program error ${instructionError[1]["Custom"]}`
        );
      }
    }
    throw Error(error.toString());
  }
};
var keypairToSecretKeyJSON = (keypair) => {
  return JSON.stringify(Array.from(keypair.secretKey));
};
var getCustomErrorMessage = (possibleProgramErrors, errorMessage) => {
  const customErrorExpression = /.*custom program error: 0x(?<errorNumber>[0-9abcdef]+)/;
  let match = customErrorExpression.exec(errorMessage);
  const errorNumberFound = match?.groups?.errorNumber;
  if (!errorNumberFound) {
    return null;
  }
  const errorNumber = parseInt(errorNumberFound, 16);
  return possibleProgramErrors[errorNumber] || null;
};
var encodeURL = (baseUrl, searchParams) => {
  const url = new URL(baseUrl);
  url.search = new URLSearchParams(searchParams).toString();
  return url.toString();
};
var getExplorerLink = (linkType, id, cluster = "mainnet-beta") => {
  const searchParams = {};
  if (cluster !== "mainnet-beta") {
    if (cluster === "localnet") {
      searchParams["cluster"] = "custom";
      searchParams["customUrl"] = "http://localhost:8899";
    } else {
      searchParams["cluster"] = cluster;
    }
  }
  let baseUrl = "";
  if (linkType === "address") {
    baseUrl = `https://explorer.solana.com/address/${id}`;
  }
  if (linkType === "transaction" || linkType === "tx") {
    baseUrl = `https://explorer.solana.com/tx/${id}`;
  }
  if (linkType === "block") {
    baseUrl = `https://explorer.solana.com/block/${id}`;
  }
  return encodeURL(baseUrl, searchParams);
};
var getKeypairFromFile = async (filepath) => {
  if (!filepath) {
    filepath = DEFAULT_FILEPATH;
  }
  if (filepath[0] === "~") {
    const home = process.env.HOME || null;
    if (home) {
      filepath = import_path.default.join(home, filepath.slice(1));
    }
  }
  let fileContents;
  try {
    const fileContentsBuffer = await (0, import_promises.readFile)(filepath);
    fileContents = fileContentsBuffer.toString();
  } catch (error) {
    throw new Error(`Could not read keypair from file at '${filepath}'`);
  }
  let parsedFileContents;
  try {
    parsedFileContents = Uint8Array.from(JSON.parse(fileContents));
  } catch (thrownObject) {
    const error = thrownObject;
    if (!error.message.includes("Unexpected token")) {
      throw error;
    }
    throw new Error(`Invalid secret key file at '${filepath}'!`);
  }
  return import_web3.Keypair.fromSecretKey(parsedFileContents);
};
var getKeypairFromEnvironment = (variableName) => {
  const secretKeyString = process.env[variableName];
  if (!secretKeyString) {
    throw new Error(`Please set '${variableName}' in environment.`);
  }
  let decodedSecretKey;
  try {
    decodedSecretKey = import_bs58.default.decode(secretKeyString);
    return import_web3.Keypair.fromSecretKey(decodedSecretKey);
  } catch (throwObject) {
    const error = throwObject;
    if (!error.message.includes("Non-base58 character")) {
      throw new Error(
        `Invalid secret key in environment variable '${variableName}'!`
      );
    }
  }
  try {
    decodedSecretKey = Uint8Array.from(JSON.parse(secretKeyString));
  } catch (error) {
    throw new Error(
      `Invalid secret key in environment variable '${variableName}'!`
    );
  }
  return import_web3.Keypair.fromSecretKey(decodedSecretKey);
};
var addKeypairToEnvFile = async (keypair, variableName, envFileName) => {
  if (!envFileName) {
    envFileName = ".env";
  }
  const existingSecretKey = process.env[variableName];
  if (existingSecretKey) {
    throw new Error(`'${variableName}' already exists in env file.`);
  }
  const secretKeyString = keypairToSecretKeyJSON(keypair);
  await (0, import_promises.appendFile)(envFileName, `
${variableName}=${secretKeyString}`);
};
var initializeKeypair = async (connection, options) => {
  let {
    envFileName,
    envVariableName,
    airdropAmount,
    minimumBalance,
    keypairPath
  } = options || {};
  let keypair;
  envVariableName = envVariableName || DEFAULT_ENV_KEYPAIR_VARIABLE_NAME;
  if (keypairPath) {
    keypair = await getKeypairFromFile(keypairPath);
  } else if (process.env[envVariableName]) {
    keypair = getKeypairFromEnvironment(envVariableName);
  } else {
    keypair = import_web3.Keypair.generate();
    await addKeypairToEnvFile(keypair, envVariableName, envFileName);
  }
  await airdropIfRequired(
    connection,
    keypair.publicKey,
    airdropAmount || DEFAULT_AIRDROP_AMOUNT,
    minimumBalance || DEFAULT_MINIMUM_BALANCE
  );
  return keypair;
};
var requestAndConfirmAirdrop = async (connection, publicKey, amount) => {
  const airdropTransactionSignature = await connection.requestAirdrop(
    publicKey,
    amount
  );
  const latestBlockHash = await connection.getLatestBlockhash();
  await connection.confirmTransaction(
    {
      blockhash: latestBlockHash.blockhash,
      lastValidBlockHeight: latestBlockHash.lastValidBlockHeight,
      signature: airdropTransactionSignature
    },
    // "finalized" is slow but we must be absolutely sure
    // the airdrop has gone through
    "finalized"
  );
  return connection.getBalance(publicKey, "finalized");
};
var airdropIfRequired = async (connection, publicKey, airdropAmount, minimumBalance) => {
  const balance = await connection.getBalance(publicKey, "confirmed");
  if (balance < minimumBalance) {
    return requestAndConfirmAirdrop(connection, publicKey, airdropAmount);
  }
  return balance;
};
var confirmTransaction = async (connection, signature) => {
  const block = await connection.getLatestBlockhash();
  const rpcResponse = await connection.confirmTransaction(
    {
      signature,
      ...block
    },
    "confirmed"
  );
  getErrorFromRPCResponse(rpcResponse);
  return signature;
};
var makeKeypairs = (amount) => {
  return Array.from({ length: amount }, () => import_web3.Keypair.generate());
};
var getLogs = async (connection, tx) => {
  await confirmTransaction(connection, tx);
  const txDetails = await connection.getTransaction(tx, {
    maxSupportedTransactionVersion: 0,
    commitment: "confirmed"
  });
  return txDetails?.meta?.logMessages || [];
};
var getSimulationComputeUnits = async (connection, instructions, payer, lookupTables) => {
  const testInstructions = [
    // Set an arbitrarily high number in simulation
    // so we can be sure the transaction will succeed
    // and get the real compute units used
    import_web3.ComputeBudgetProgram.setComputeUnitLimit({ units: 14e5 }),
    ...instructions
  ];
  const testTransaction = new import_web3.VersionedTransaction(
    new import_web3.TransactionMessage({
      instructions: testInstructions,
      payerKey: payer,
      // It seems that recentBlockhash can by any public key duiring simulation
      recentBlockhash: import_web3.PublicKey.default.toString()
    }).compileToV0Message(lookupTables)
  );
  const rpcResponse = await connection.simulateTransaction(testTransaction, {
    replaceRecentBlockhash: true,
    sigVerify: false
  });
  getErrorFromRPCResponse(rpcResponse);
  return rpcResponse.value.unitsConsumed || null;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  addKeypairToEnvFile,
  airdropIfRequired,
  confirmTransaction,
  getCustomErrorMessage,
  getExplorerLink,
  getKeypairFromEnvironment,
  getKeypairFromFile,
  getLogs,
  getSimulationComputeUnits,
  initializeKeypair,
  keypairToSecretKeyJSON,
  makeKeypairs
});
